%\section*{Лекцион 1}
%\addcontentsline{toc}{section}{Лекцион 1}
%\addtocounter{section}{1}
\section{Лекцион 1}


Ваш лектор сегодня не смог прийти. Книга Бахвалова, Жидкова, Кобелькова будет рассказана за два семестра. 

Почему нечётко всё будет формулироваться с точки зрения математика. В вычислительной математике мало предъявить алгоритм или доказать, что решение есть. Нужно ещё оценить качество этого алгоритма.
\subsection{Вычислительная погрешность}
Три требования к задаче и алгоритму.
\begin{enumerate}
\item Устойчивость задачи.
\item Устойчивость алгоритма.
\item Вычислительные ресурсы.
\end{enumerate}
Если вам дают задачу, сначала смотрите как обычный математик, а затем загибаете пальцы, проверяя эти три пункта.

Что такое устойчивость задачи.

\subsubsection{Матрица Уилкинсона}
Вот такая матрица $20\times20$.
\[
  \begin{pmatrix}
  20 & 20 & 0  & 0\\
  0  & 19 & 20 & 0\\
  0 & \ddots & \ddots & \ddots\\
  0 & &&\dots 1
\end{pmatrix}
\]
Считаем определелитель (на главной диагонали $i!$ на следующей справа по 20), получаем $20!$. А теперь пусть нас просят его посчитать, про том, что числа могут чуть-чуть отличаться на $\e$. Например, левый нижний элемент $\e$.
\[
  \det (A_\e - \lambda I) = (20 - \lambda)\dots (1-\lambda) - \e 20^{19} = 0.
\]
Тогда $\e = 20^{-19}\cdot 20!\sim 5 \cdot 10^7$. Тогда $|\lambda|_{\min}(A_\e) = 0$, $\det A_\e =0$.

Чтобы понимать масштаб то, что происходит. Пусть $5\cdot10^{-7}$ км. Это пол миллиметра. А что такое $20!\sim 2{,}4\cdot 10^{18}\,$км "--- млечный путь.

Это был пример неустойчивость задачи. Введение маленького возмущения колоссально меняет результат.

\subsubsection{Услойчивость алгоритма}
 Рассмотрим $f(x) = (x-10^3)(x-10^{-3})=0$. $x_1 = 10^{-3}$, $x_2 = 10^{3}$. Ну или
\[
  x^2 - 2a x + 1 = 0.
\]
$2a$ это на самом деле $10^3 + 10^{-3}$.
Итого $x_1^{(1)} = a - \sqrt{a^2 - 1}$.

Если говорить в терминах C, мы кладём результат в double. $x_1^{(1)}$ имеет 10 верных цифр. 64 бита для хранения.
\[
  \big|f(x^{(1)}\big|\sim 10^{-11}.
\]

Как меняется переменная $x\sim 10^{\pm 308}$. Машинная точность double exp=1.
\begin{verbatim}
double eps=1;
while (1+eps<1) eps = eps/2;
\end{verbatim}

Если $x$ порядка единицы, то машинная точность $\e\sim 10^{-16}$.

То есть плохой наш алгоритм, как быть? Домножим на сопряжённое
\[
  x_1^{(2)} = \frac1{a + \sqrt{a^2-1}}.
\]
В этом случае $x_1^{(2)}$ имеет 17 значащих цифр. При этом $\big|f(x_1^{(2)})\big|\sim 10^{-18}$.

Это был пример неустойчивого алгоритма. С большим количеством операций, скопится неточность.

Рассмотрим $\RY i1{10^3}\frac1{i^2}$. В каком порядке считать? Слева направо или справа налево? Совпадение получится в 14 знаках, а не 18. Какой более устойчивый: с маленьких чисел к большим.

Поставим абсурдную задачу $\rY i1\frac1i$. Всем известно, что ряд расходится, сможем ли мы это зафиксировать? Мы с какого-то момента будем прибавлять к большой накопленной сумме слишком маленькую добавку. Сумма просто не будет меняться.

\subsubsection{Вычислительные ресурсы}

СЛАУ $Ax = b$. Метод Крамера. Считаем $(n+1)$ определитель методом миноров, каждый определитель считается за $n!\cdot n$ арифметических действий. В итоге получается $n\cdot(n+1)!$.

Возьмём $n=20$ "--- количество строк; и параллельно $n=100$. Тогда сложность алгоритма $N(20)\sim 20\cdot 21\cdot 20! \sim 10^{21}$ арифметических операций. То есть в процессоре число атомов соизмеримо с числом арифметических операций. Процессором i7 $50\cdot 10^9 flops$, то есть столько операций в секунду. В году $3\cdot 10^7$ секунд. То есть нам потребует $650$ лет.

Плохая программа в секунду делает больше ошибок, чем человек за всю жизнь.

Дома посчитайте $n=100$. Посчитайте сколько времени займёт на Ломоносове. Сравните с возрастом вселенной.


В вычислительной математике важно не число, а понимание того, что вы сделаете.

\subsection{Теория приближения функции одной переменной многочленами}
Приближаем $f(x)$, $x\in\R$. Очень важно правильно сформулировать задачку.

Дано. На отрезочке $[a,b]$ рассыпан набор точек $a \le <x_1<x_2<\dots< x_n\le b$. Имеем $f$ "--- гладкая на $[a,b]$. Требуется построить полином.

Найти $p(x)\colon p(x_i) = f(x_i)$ для всех $i=1,\dots,n$.

Можно поставить другую задачу: не точное совпадение, а близкое. Получится по-другому.

Имеем $p_{n-1}(x) = a_0 + a_1 x + \dots + a_{n-1}x^{n-1}$. Описываем систему
\[
  \begin{pmatrix}
  1 & x_1 & \dots &x_1^{n-1} \\
  \vdots & \vdots &\ddots &\vdots \\
  1 & x_n & \dots &x_n^{n-1}
\end{pmatrix}
\begin{pmatrix}
a_0 \\ \vdots \\ a_{n-1}
\end{pmatrix} = 
\begin{pmatrix}
  f(x_1)\\ \vdots\\ f(x_n)
\end{pmatrix}
\]

При этом условие $\det A\ne 0$ может нарушаться из-за машинной точности. Формально определитель Вандермонда не ноль, но строки могут быть очень близки при большом количестве точек. Получится в итогу нулевая функция, быстро уходящая в 1 в правом конце отрезка.

\begin{Lem}
  Пусть $x_1<x_2<\dots<x_{n_1}<x_n$, заданы $\big\{f(x_i)\big\}_{i=1}^n$. Тогда 
\[
  \exists!\ P_{n_1}(x),\ \deg P_{n-1}=n-1\colon P_{n-1}(x_i)=f(x_i).
\]
\end{Lem}
Мы это показали. Но не надо формально систему уравнений на коэффициенты считать.

Рассмотрим пример: функция Рунге на отрезке $[-1,1]$. Берётся равномерная сеточка $x_i = -1 + (i-1)\cdot h$, $x_n=1$. Функция сама $f(x) = \frac1{1+ 25 x^2}$. Многочлен $P_{n-1}(x)$ существует и единственный. Любопытно с помощью какого-нибудь пакета посмотреть, как это получается.  В отрезке есть мёртвая зона, где при $n\to\infty$ нет будет сходимости по норме Чебышёва. Но где-то будет хорошо.

Второй пример. $f(x) = | x|$. В этом случае $\|f-p_{n-1}\|_C\not\to 0$ на равномерной сетке.

Перед тем как приближать, нужно понять, а хорошо ли эту функцию можно приблизить полиномами.

\begin{The}[Фабера]
  Для произвольной таблицы узлов интерполяции
\[
  \begin{matrix}
 x_1^{(1)}\\
 x_1^{(2)} & x_2^{(2)} \\
 x_1^{(3)} & x_2^{(3)} & x_3^{(3)} \\
 \vdots & \vdots & \vdots & \ddots
\end{matrix}
\] 
Все $x_i^{(j)}\in[a,b]$. Для такой таблицы существует $f\in C[a,b]\colon \|f-p_{n-1}\|_C\not\to 0$.
\end{The}
Доказывать не будем, нам не надо. Хотя функция строится конструктивно.

Замечание. Пусть $f\in C^\infty[a,b]$, $\{x_i\}_{i=1}^n$ "--- чебышёвские узлы. Тогда $\|f - p_{n-1}\|_C\le C q^n$, где $q<1$, $c = c(f)$.

\subsection{Интерполяционный полином в форме Лагранжа}
Он будет записывать не через коэффициенты. Ведь $1,x,x^2,\dots$ почти линейно зависимы. Мы будем брать базис ортогональных многочленов.

Пусть $\Phi_i(x) = \prod\limits_{j\ne i}\frac{(x-x_j)}{(x_i-x_j)}$. Как выглядит первая $\Phi_1(x) = \frac{(x - x_2)\dots (x-x_1)}{(x_1-x_2)\dots(x_1-x_n)}$.

Тогда $p_{n-1}(x) = \RY i1n f(x_i)\cdot \Phi_i(x)$. Обозначение $L_n(x)$. По существованию и единственности это тот же полином.

Замечание $\deg \big(L_n(x)\big) = n-1$. Этот момент уточните с лектором. Может быть, он обозначает $L_{n-1}$.

Замечание. Оптимальное вычисление. Если есть полином $p_{n-1}(x) = a_0 + a_1 x+ \dots + a_{n-1} x^{n-1}$. Нужно вычислить значение в точке.
\begin{verbatim}
  p = 0;
  for (i=0; i<n; i++){
    p = p + a[i] * pow(x,i);
  }
\end{verbatim}
Это долго. Нужно домножать предыдущий $x_n = x_n\cdot \ol x$ на точку, а не считать заново степень. Это уже лучше.

Есть на самом деле ещё более быстрый способ. Оптимальная схема: схема Горнера.
\[
  p_{n-1}(x) = a_0 + x\Big(a_1 + x\big(a_2 + \dots + x(a_{n-2} + x a_{n-1})\big)\Big).
\]
Это способ имеет сложность $O(n)$.
Такое алгоритм достаточно устойчив к погрешности.

А как вычислять значение многочлена Лагранжа.
\[
  L_n(x) = f(x_1) \cdot \frac{ (x-x_2)\dots (x-x_n)}{(x_1-x_2)\dots(x_1-x_{n-1}}+\dots
\]
Лучше делить сначала $\frac{x-x_2}{x_1-x_2}$, потом следующую пару. Так меньше ошибок накопится.

\begin{The}
  Пусть $f\in C^n[a,b]$. Соответственно $a=x_1<\dots<x_n=b$. Тогда
\[
  \forall\ x\in[a,b]\exists\ \xi = \xi(x) = \in[a,b]\colon 
  f(x) - L_n(x) = \frac{f^{(n)}\big(\xi(x)\big)}{n!}\omega_n(x),
\]
где $\omega_n(x) = (x - x_1)\dots (x-x_n)$.
\end{The}
\begin{Proof}
 Пошаговое
\begin{enumerate}
\item Пусть $x=x_i$, $i=1..n$. Тогда $0=0$ верно.
\item Пусть $x\in [a,b]$, $x\ne x_i$. Рассмотрим функцию
\begin{equation}\label{1tech1}
  \phi(t) = f(t) - L_n(t) - k\omega_n(t),
\end{equation}
где коэффициент $k\colon \phi(t)\big|_{t=x}=0$. Отсюда следует, что $k = \frac{f(x) - L_n(x)}{\omega_n(x)}$.

Тогда $\phi(t)$ обращается в нуль в точках $t=x,x_1,x_2,\dots,x_n$. Отсюда следует, что $\phi'(t)$ обращается в нуль в $n$ точках, $\phi^{(n)}(t)$ образается в ноль в некоторой точке $\xi = \xi(x)\in[a,b]$.

Возьмём теперь равенство \eqref{1tech1} и продифференцируем
\[
  \phi^{(n)}(t)\big|_{t=\xi} = f^{(n)}(t)\big|_{t=\xi} - 0 - k n!.
\]
Отсюда $k=\frac{f^{(n)}(\xi)}{n!}$. И ведь $k = \frac{f(x)-L_n(x)}{\omega_n(x)}$ и теорема доказана.
\end{enumerate}
\end{Proof}
\begin{Sl}
В условиях теоремы верна оценка
\[
  \|f-L_n\|_C\le \frac{\| f^{(n)}\|_C}{n!} \|\omega_n\|_C.
\]
\end{Sl}

\subsection{Константа Лебега}
Пусть $L_n(x) = \RY i1n f(x_i) \Phi_i(x)$. Пусть изменится $f(x_i)$ на $f(x_i)+\e_i$. Константой Лебега называют величину
\[
  \lambda_n = \max\limits_{x\in[a,b]} \RY i1n \big|\Phi_i(x)\big|.
\]

Если $x_i = x_{i-1} + h$ "--- равномерные узлы, то $c_1\cdot \frac{2^n}{n^{3/2}}\le \lambda_n \le c_2 \cdot 2^n$.

Если $\{x_i\}$ "--- чебышёвские узлы, то $\lambda_n c_3\ln n$. А логирифм это почти константа.
